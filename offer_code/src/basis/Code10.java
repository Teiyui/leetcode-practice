package basis;

/**
 * 题目：剑指 Offer 10- II. 青蛙跳台阶问题
 * 题目要求：一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。
 * 题目分析：1. 看到此类问题，首先想到使用动态规划解决问题
 *         2. 动态规划的要点: 1). 核心：设置一维数组或二维数组作为变量保存历史记录，防止重复计算
 *                         2). 步骤一：定义数组元素的含义（假设dp[n]），此例中dp[n]就代表跳上一个n级台阶共有多少种跳法
 *                         3). 步骤二：找出数组元素之间的关系式，例如此例中就为dp[n] = dp[n-1] + dp[n-2]
 *                         4). 步骤三：找出初始值，目的是防止索引出现负数的情况
 */
public class Code10 {

    /**
     * 方法一：非优化动态规划
     * 解题思路：1. 确定动态规划表达式为dp[n]
     *         2. 确定数组元素之间关系式为dp[n] = dp[n-1] + dp[n-2]
     *         3. 确定初始值为n=2，遍历至等于n为止
     *         4. 注意：当n=2时，dp[2]的值应为1+1=2（不能忽视dp[2]作为条件的存在）
     *         5. 步骤: 1). 建立数组，长度为n+1，目的是索引有n这个值
     *                 2). 因为是n=2时开始遍历数组，所以边界条件为0或1的n直接返回1
     *                 3). 设dp[0] = 1, dp[1] = 1
     *                 4). 遍历数组，边界条件为i大于n，开展动态规划
     *                 5). 为了防止溢出，采用%质数Math.pow(10, 9) + 7的步骤，原因为该数为质数且(a+b)%c = ((a%c) + (b%c))%c
     */

    public int numWays(int n) {
        if (n == 0 || n == 1) {
            return 1;
        }
        int[] dp = new int[n+1];
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            dp[n] = dp[n-1] + dp[n-2];
            dp[n] %= (Math.pow(10, 9) + 1);
        }
        return dp[n];
    }

    /**
     * 方法二：优化动态规划（空间复杂度优化->将O(n)变为O(1)）
     * 解题思路：1. 由于dp列表的第i项只与第i-1和第i-2项相关，我们可以设置三个整型变量sum、a、b，利用辅助变量sum使a、b两数字交替前进即可
     *         2. 因为这里省略掉了dp列表，所以空间复杂度变为O(1)
     */

    public int numWays_Optimization(int n) {
        if (n <= 1) {
            return 1;
        }
        int a = 1; // 可以当作dp[n-2]
        int b = 1; // 可以当作dp[n-1]
        int sum;
        for (int i = 0; i < n ; i++) {
            sum = (a+b) % 1000000007; // 这里的a和b相当于从1和2开始的
            a = b;
            b = sum;
        }
        return a;
    }
}

